import{o as s,a as o,e as a,t as i,D as n}from"./index-f7adda7a.js";const r={class:"markdown-body"},h=n('<h3>Delivering a Smooth Experience</h3><p>In my <a href="https://paperbaglife.github.io/#/blogs/2025-06-05-blog-on-github-pages">previous blog post</a>, I talked about how I created a utilities website to track the status of High-Power-Computing (HPC) servers. This was a fun little side project that I could work on intermittently, depending on my workload.</p><p>As a complete beginner in user experience, my goal was to get the website into a “working” state as quickly as possible.</p><p>For the backend, I quickly whipped up a Flask server in Python and created a systemd service file to run the server. For the frontend, I started with a Vue template and simply added a table to display the statuses. Done.</p><p>The result? Upon visiting the page, the web server had to <code>ssh</code> into the HPC servers (naively, in a for-loop), run expensive command-line tools, and parse the results. The user had to watch a spinning loading icon for a whole minute while the server fetched the status for all the machines.</p><p>The website went live, and I was pretty much the only user.</p><h4>Time to Content: 1 minute</h4><p>My first instinct was to parallelize the <code>ssh</code> commands using threads. This worked, but since the command-line tools still took time, it would still take 10–20 seconds for the results to show up.</p><p>At this point, several engineers were using the website to check the servers’ statuses before running NCCL jobs. One coworker waited for 5 seconds and, seeing nothing, asked if the website was broken. I remember adding a line to the website to mock him for his impatience.</p><h4>Time to Content: 10-20 seconds</h4><p>After a period of back-to-back tickets, I was finally able to revisit this project. I thought about using a cache since most results were static states most of the time.</p><p>I implemented a cache to fetch the status every 30 seconds, save the results, and return the latest result immediately upon receiving a request. (Something something thread safety - just throw a lock on there.) This reduced the time-to-content to less than 1 second.</p><h4>Time to Content: &lt;1 second</h4><p>At this point, I was pretty satisfied with the website. Over time, I added buttons to help organize various documents and internal links relevant to the project, as well as a cookbook of common commands and knowledge specific to our internal cluster.</p><p>Engineers use it daily (at least from 2025-04-20 to the day this was written) to access documents or find commands to run from the Cookbook.</p><p>The Cookbook<sup>TM</sup> is another fantastic case study in user experience, and I shall discuss it in the next blog.</p>',16),u="User Experience - a Case Study",m="2025-06-06T00:00:00.000Z",w=["Vue","Flask","UX"],g={__name:"2025-06-06-UX-learnings",setup(l,{expose:t}){const e={title:"User Experience - a Case Study",date:"2025-06-06T00:00:00.000Z",tags:["Vue","Flask","UX"]};return t({frontmatter:e}),(c,d)=>(s(),o("div",r,[a("h1",null,i(e.title),1),h]))}};export{m as date,g as default,w as tags,u as title};
